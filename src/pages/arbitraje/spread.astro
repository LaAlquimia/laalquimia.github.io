---
const { symbol } = Astro.params
---
<div id="ppal" class="flex flex-col items-center justify-center w-full">
    <h3>Arbitraje</h3>
    <div class="order-book-container text-white flex flex-row items-center justify-center space-x-5">
        <div id="btcusdttable" class="order-book">
            <h4>BTCUSDT</h4>
            <div id="BTCUSDTaskprice">
                <p>Ask</p>
            </div>
            <div id="BTCUSDTbidprice">
                <p>Bid</p>
            </div>
        </div>
        <div id="ethusdttable" class="order-book">
            <h4>ETHUSDT</h4>
            <div id="ETHUSDTaskprice">
                <p>Ask</p>
            </div>
            <div id="ETHUSDTbidprice">
                <p>Bid</p>
            </div>
        </div>
        <div id="ethbtctable" class="order-book">
            <h4>ETCBTC</h4>
            <div id="ethbtcaskprice">
                <p>Ask</p>
            </div>
            <div id="ethbtcbidprice">
                <p>Bid</p>
            </div>
        </div>
    </div>

    <div id="tetttable" class="order-book">
        <h4>tetT</h4>
        <div id="tettaskprice">
            <p>Ask</p>
        </div>
        <div id="tettbidprice">
            <p>Bid</p>
        </div>
    </div>
</div>
<script>
    interface OrderBooks {
        [key: string]: {
            bids: Map<any, any>;
            asks: Map<any, any>;
        };
    }
    const orderBook = {
        bids: new Map(),
        asks: new Map(),
    };

    const orderBooks = {
        BTCUSDT: { bids: new Map(), asks: new Map() },
        ETHUSDT: { bids: new Map(), asks: new Map() },
        ETHBTC: { bids: new Map(), asks: new Map() },
    };
    const btcusdt = new WebSocket(
        "wss://stream.bybit.com/v5/public/spot",
    );
    //
    btcusdt.onopen = () => {
        btcusdt.send(
            JSON.stringify({
                op: "subscribe",
                args: [
                    "orderbook.1.BTCUSDT",
                    "orderbook.1.ETHUSDT",
                    "orderbook.1.ETHBTC",
                ],
            }),
        );
        console.log("connected");
    };

    btcusdt.onmessage = (event) => {
        const data = JSON.parse(event.data);
        const market = data.data?.s;

        console.log(data?.data);
        if (market == "BTCUSDT") {
            const priceElement =
                document.getElementById("BTCUSDTaskprice")!;
            const bidElement =
                document.getElementById("BTCUSDTbidprice")!;
            if (data?.type === "snapshot") {
                priceElement.innerHTML = "";
                bidElement.innerHTML = "";

                // Iterar sobre los datos del snapshot y actualizar el orderBook
                for (const [price, quantity] of data.data.a) {
                    // match orderBook with market symbol
                    const existingOrder = orderBook.asks.get(price);

                    if (existingOrder) {
                        existingOrder.quantity = quantity;
                    } else {
                        orderBook.asks.set(price, { price, quantity });
                    }
                }

                for (const [price, quantity] of data.data.b) {
                    const existingOrder = orderBook.bids.get(price);
                    if (existingOrder) {
                        existingOrder.quantity = quantity;
                    } else {
                        orderBook.bids.set(price, { price, quantity });
                    }
                }

                // Mostrar el orderBook en el HTML
                updateOrderBookUI(orderBook, priceElement, bidElement);
            } else if (data?.type === "delta") {
                // Actualizar el orderBook con los cambios del delta
                for (const [price, quantity] of data.data.a) {
                    const existingOrder = orderBook.asks.get(price);
                    if (existingOrder) {
                        if (quantity === "0") {
                            orderBook.asks.delete(price);
                        } else {
                            existingOrder.quantity = quantity;
                        }
                    } else {
                        orderBook.asks.set(price, { price, quantity });
                    }
                }

                for (const [price, quantity] of data.data.b) {
                    const existingOrder = orderBook.bids.get(price);
                    if (existingOrder) {
                        if (quantity === "0") {
                            orderBook.bids.delete(price);
                        } else {
                            existingOrder.quantity = quantity;
                        }
                    } else {
                        orderBook.bids.set(price, { price, quantity });
                    }
                }

                // Mostrar el orderBook actualizado en el HTML
                updateOrderBookUI(orderBook, priceElement, bidElement);
            }
        }

        if (market == "ETHUSDT") {
            const ETHpriceElement =
                document.getElementById("ETHUSDTaskprice")!;
            const bidElement =
                document.getElementById("ETHUSDTbidprice")!;
            if (data?.type === "snapshot") {
                ETHpriceElement.innerHTML = "";
                bidElement.innerHTML = "";

                // Iterar sobre los datos del snapshot y actualizar el orderBook
                for (const [price, quantity] of data.data.a) {
                    // match orderBook with market symbol
                    const existingOrder = orderBook.asks.get(price);

                    if (existingOrder) {
                        existingOrder.quantity = quantity;
                    } else {
                        orderBook.asks.set(price, { price, quantity });
                    }
                }

                for (const [price, quantity] of data.data.b) {
                    const existingOrder = orderBook.bids.get(price);
                    if (existingOrder) {
                        existingOrder.quantity = quantity;
                    } else {
                        orderBook.bids.set(price, { price, quantity });
                    }
                }

                // Mostrar el orderBook en el HTML
                updateOrderBookUI(orderBook, ETHpriceElement, bidElement);
            } else if (data?.type === "delta") {
                // Actualizar el orderBook con los cambios del delta
                for (const [price, quantity] of data.data.a) {
                    const existingOrder = orderBook.asks.get(price);
                    if (existingOrder) {
                        if (quantity === "0") {
                            orderBook.asks.delete(price);
                        } else {
                            existingOrder.quantity = quantity;
                        }
                    } else {
                        orderBook.asks.set(price, { price, quantity });
                    }
                }

                for (const [price, quantity] of data.data.b) {
                    const existingOrder = orderBook.bids.get(price);
                    if (existingOrder) {
                        if (quantity === "0") {
                            orderBook.bids.delete(price);
                        } else {
                            existingOrder.quantity = quantity;
                        }
                    } else {
                        orderBook.bids.set(price, { price, quantity });
                    }
                }

                // Mostrar el orderBook actualizado en el HTML
                updateOrderBookUI(orderBook, ETHpriceElement, bidElement);
            }
        }
    };

    // Funci√≥n para actualizar el HTML con los datos del orderBook
    function updateOrderBookUI(orderBook, askPrice, bidPrice) {
        // Limpiar el HTML antes de actualizarlo
        askPrice.innerHTML = "";
        bidPrice.innerHTML = "";

        // Iterar sobre los asks y mostrarlos en el HTML
        for (const [price, order] of orderBook.asks) {
            const askRow = document.createElement("div");
            askRow.textContent = ` ${order.price}`;
            askPrice.appendChild(askRow);
        }

        // Iterar sobre los bids y mostrarlos en el HTML
        for (const [price, order] of orderBook.bids) {
            const bidRow = document.createElement("div");
            bidRow.textContent = `${order.price}`;
            bidPrice.appendChild(bidRow);
        }
    }
</script>